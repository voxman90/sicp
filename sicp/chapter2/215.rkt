#lang sicp

#|
  Упражнение 2.15

  Ева Лу Атор, другой пользователь Лизиной программы, тоже заметила, что алгебраически эквивалентные,
  но различные выражения могут давать разные результаты. Она говорит, что формула для вычисления
  интервалов, которая использует Лизину систему, будет давать более узкие границы погрешности, если
  ее удастся записать так, чтобы ни одна переменная, представляющая неточную величину, не повторялась.
  Таким образом, говорит она, par2 «лучше» как программа для параллельных резисторов, чем par1. Права
  ли она? Почему?
|#

#|
    А = (a - w, a + w)

    A - A = (a - w - (a + w), a + w - (a - w)) = (0 - 2w, 0 + 2w)

    A/A = (a - w, a + w)/(a - w, a + w) = (a - w, a + w)*(1/(a + w), 1/(a - w)) =

    = (min((a + w)/(a - w), 1, (a - w)/(a + w)), max((a + w)/(a - w), 1, (a - w)/(a + w))) =

    = (min(1 + 2w/(a - w), 1, 1 - 2w/(a + w)), max(1 + 2w/(a - w), 1, 1 - 2w/(a + w))

  Если w > 0, то:

    A/A ≠ (1, 1), w(A/A) ≠ 0

  Интервалы, которые представляют точные величины (с нулевой погрешностью), в интервальной арифметике
  дают точный результат.

  Мы знаем, что алгебраически эквивалентные выражения могут давать разный результат для интервалов.
  Известна и причина этого - разность и отношение интервала представляющего величину с ненулевой
  погрешностью не равна (0, 0) и (1, 1) соответственно. Преобразования эквивалентные для точных величин
  вовсе не эквивалентны для интевалов представляющих неточные величины.
  Но этого недостаточно, чтобы обосновать тезис Евы Лу Атор. Необходимо ещё показать, что погрешности
  при всех операциях с неточными величинами не уменьшаются или растут.

    А = (a - w₁, a + w₁), B = (b - w₂, b + w₂)

    (A + B) = (a - w₁, a + w₁) + (b - w₂, b + w₂) = ((a + b) - (w₁ + w₂), (a + b) + (w₁ + w₂))

    (A - B) = (a - w₁, a + w₁) + (b - w₂, b + w₂) = ((a - b) - (w₁ + w₂), (a - b) + (w₁ + w₂))

  Деление в арифметике интервалов сводится к умножению, потому достаточно рассмотреть умножение. легко
  подобрать пример, когда погрешность (радиус) после умножения уменьшается.

    (1/20, 1/10)*(1/4, 3/4) = (1/80, 1/40)

  Проверим на практике:
|#

(define (make-interval a b)
  (cons a b))

(define (lower-bound interval)
  (car interval))

(define (upper-bound interval)
  (cdr interval))

(define (center interval)
  (/ (+ (lower-bound interval)
        (upper-bound interval))
     2))

(define (width interval)
  (/ (- (upper-bound interval)
        (lower-bound interval))
     2))

(define (percent interval)
  (* 100
     (/ (width interval)
        (abs (center interval)))))

(define (add-interval a b)
  (make-interval (+ (lower-bound a) (lower-bound b))
                 (+ (upper-bound a) (upper-bound b))))

(define (mul-interval a b)
  (let ((p1 (* (lower-bound a) (lower-bound b)))
        (p2 (* (lower-bound a) (upper-bound b)))
        (p3 (* (upper-bound a) (lower-bound b)))
        (p4 (* (upper-bound a) (upper-bound b))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define i1 (make-interval (/ 1 20) (/ 1 10)))
(define i2 (make-interval (/ 1 4) (/ 3 4)))
(define i1*i2 (mul-interval i1 i1))
(define i1+i2 (add-interval i1 i1))

(width i1)
(width i2)
(width i1*i2)
(width i1+i2)

(percent i1)
(percent i2)
(percent i1*i2)
(percent i1+i2)

#|
  Если погрешность и уменьшилась, то погрешность в процентах выросла. Возможно ли показать в общем
  случае, что погрешность в процентах не уменьшается или растёт? Так ли это?

    a, b ≠ 0, p₁> 0, p₂ > 0

    А = (c₁ - cp₁, c₁ + c₁p₁), B = (c₂ - c₂p₂, c₂ + c₂p₂)

    p(A + B) = w(A + B)/c(A + B) = (w(A) + w(B))/c(A + B) = (|c₁|p₁ + |c₂|p₂)/|c₁ + c₂|

  Пусть 0 < p₁ ≤ p₂, допустим:

    p(A + B) = (|c₁|p₁ + |c₂|p₂)/|c₁ + c₂| < p₁, |c₁|p₁ + |c₂|p₂ < p₁|c₁ + c₂|,

    p₂ < p₁(|c₁ + c₂| - |c₁|)/|c₂|, 1 ≤ p₂/p₁ < (|c₁ + c₂| - |c₁|)/|c₂|, 1 < (|c₁ + c₂| - |c₁|)/|c₂|

    |c₁| + |c₂| < |c₁ + c₂| (!)

  Мы получили противоречие, значит послыка неверна и p(A + B) ≥ p₁. Т.е. погрешность в процентах в
  лучшем случае равна меньшей погрешности в процентах операндов. (Для случая, когда 0 < p₂ ≤ p₁
  доказательство аналогично).

  Разность можно рассмтаривать, как A + ((0, 0) - B).

  Покажем, что погрешность в процентах не уменьшается и для умножения интервалов:

    E = [(c₁ - |c₁|p₁)(c₂ - |c₂|p₂), = [c₁c₂ - |c₁|c₂p₁ - c₁|c₂|p₂ + |c₁c₂|p₁p₂,
         (c₁ - |c₁|p₁)(c₂ + |c₂|p₂),    c₁c₂ - |c₁|c₂p₁ + c₁|c₂|p₂ - |c₁c₂|p₁p₂,
         (c₁ + |c₁|p₁)(c₂ - |c₂|p₂),    c₁c₂ + |c₁|c₂p₁ - c₁|c₂|p₂ - |c₁c₂|p₁p₂,
         (c₁ + |c₁|p₁)(c₂ + |c₂|p₂)]    c₁c₂ + |c₁|c₂p₁ + c₁|c₂|p₂ + |c₁c₂|p₁p₂]

    p(AB) = (min(E), max(E))

  Здесь множество исходов, но для некоторых из них доказательство проводится аналогично (помогает
  коммутативность умножения интервалов), поэтому достаточно рассмотреть лишь "типовые" исходы.

  Рассмотрим случай, когда концы первого и второго интервала положительны, т.е.: 0 < c₁ - |c₁|p₁,
  0 < c₂ - |c₂|p₂, c₁ > 0, c₂ > 0. Предположим, что 0 < p₁ ≤ p₂:

    p(AB) = p(c₁c₂ - |c₁|c₂p₁ - c₁|c₂|p₂ + |c₁c₂|p₁p₂, c₁c₂ + |c₁|c₂p₁ + c₁|c₂|p₂ + |c₁c₂|p₁p₂) =

    = (|c₁|c₂p₁ + c₁|c₂|p₂)/｜c₁c₂ + |c₁c₂|p₁p₂｜ = (p₁ + p₂)/(1 + p₁p₂)

  Допустим, что:

    (p₁ + p₂)/(1 + p₁p₂) < p₂ ⇒ p₁ + p₂ < p₂ + p₁p₂p₂ ⇒ p₁ < p₁p₂p₂ ⇒ 1 < p₂p₂ ⇒ 0 < p₂p₂ - 1 ⇒

    ⇒ 0 < (p₂ - 1)(p₂ + 1) ⇒ 0 < p₂ - 1 ⇒ 1 - p₂ < 0 (!)*

  * По условию 0 < c₂ - |c₂|p₂, c₂ > 0 ⇒ 0 < 1 - p₂)

  Следовательно, p(AB) ≥ p₂ ≥ p₁. (Для p₂ ≤ p₁ доказывается аналогично в этом и последующих случаях,
  если не оговорено иного).

  Рассмотрим случай, когда концы первого из интервалов отрицательны, а второго - положительны, т.е.:
  c₁ + |c₁|p₁ < 0, 0 < c₂ - |c₂|p₂, c₁ < 0, c₂ > 0. Предположим, что 0 < p₁ ≤ p₂:

    p(AB) = p(c₁c₂ - |c₁|c₂p₁ + c₁|c₂|p₂ - |c₁c₂|p₁p₂, c₁c₂ + |c₁|c₂p₁ - c₁|c₂|p₂ - |c₁c₂|p₁p₂) =

    = (|c₁|c₂p₁ - c₁|c₂|p₂)/｜c₁c₂ - |c₁c₂|p₁p₂｜ = (p₁ + p₂)/(1 + p₁p₂)

  Допустим, что:

    (p₁ + p₂)/(1 + p₁p₂) < p₂ ⇒ 1 - p₂ < 0 (!)

  Рассмотрим случай, когда концы первого интервала разных знаков, а второго - положительны, т.е.:
  c₁ - |c₁|p₁ < 0, c₁ + |c₁|p₁ > 0, 0 < c₂ - |c₂|p₂, c₂ > 0.

    p(AB) = p(c₁c₂ - |c₁|c₂p₁ + c₁|c₂|p₂ - |c₁c₂|p₁p₂, c₁c₂ + |c₁|c₂p₁ + c₁|c₂|p₂ + |c₁c₂|p₁p₂) =

    = (|c₁|c₂p₁ + |c₁c₂|p₁p₂)/｜c₁c₂ + c₁|c₂|p₂｜ = p₁

  Мы рассмотрели случаи, когда интервалы лежат на разных полуосях и случаи, когда один из интервалов
  пересекает центр координат, а второй - нет. Случаи нулевых границ рассматриваются аналогично и ничего
  нового не привносят. Осталось рассмотреть случай, когда оба интервала пересекают центр координатной
  оси. Для каждого из них: c₁ - |c₁|p₁ < 0, c₁ + |c₁|p₁ > 0, c₂ - |c₂|p₂ < 0, c₂ + |c₂|p₂ > 0, 0 < p₁,
  0 < p₂.

  Случай первый:

    (a) (c₁ - |c₁|p₁)(c₂ + |c₂|p₂) < (c₁ + |c₁|p₁)(c₂ - |c₂|p₂) ⇒

    ⇒ (c₁ - |c₁|p₁)(c₂ + |c₂|p₂) - (c₁ + |c₁|p₁)(c₂ - |c₂|p₂) < 0 ⇒

    ⇒ c₁c₂ - |c₁|c₂p₁ + c₁|c₂|p₂ - |c₁c₂|p₁p₂ - c₁c₂ - |c₁|c₂p₁ + c₁|c₂|p₂ + |c₁c₂|p₁p₂ < 0 ⇒

    ⇒ c₁|c₂|p₂ - |c₁|c₂p₁ < 0 ⇒ c₁|c₂|p₂ < |c₁|c₂p₁ ⇒ c₁p₂/|c₁| < c₂p₁/|c₂|

    (b) (c₁ - |c₁|p₁)(c₂ - |c₂|p₂) < (c₁ + |c₁|p₁)(c₂ + |c₂|p₂) ⇒

    ⇒ (c₁ - |c₁|p₁)(c₂ - |c₂|p₂) - (c₁ + |c₁|p₁)(c₂ + |c₂|p₂) < 0 ⇒

    ⇒ c₁c₂ - |c₁|c₂p₁ - c₁|c₂|p₂ + |c₁c₂|p₁p₂ - c₁c₂ - |c₁|c₂p₁ - c₁|c₂|p₂ - |c₁c₂|p₁p₂ < 0 ⇒

    ⇒ |c₁|c₂p₁ + c₁|c₂|p₂ > 0 ⇒ |c₁|c₂p₁ > - c₁|c₂|p₂ ⇒ c₂p₁/|c₂| > - c₁p₂/|c₁|

  (a) и (b) даёт два варианта:

    1) c₁ < 0, c₂ > 0, 0 < p₂ < p₁

    2) c₁ > 0, c₂ > 0, 0 < p₂ < p₁

    p(AB) = p((c₁ - |c₁|p₁)(c₂ + |c₂|p₂), (c₁ + |c₁|p₁)(c₂ + |c₂|p₂)) =

    = p(c₁c₂ - |c₁|c₂p₁ + c₁|c₂|p₂ - |c₁c₂|p₁p₂, c₁c₂ + |c₁|c₂p₁ + c₁|c₂|p₂ + |c₁c₂|p₁p₂) =

    = (|c₁|c₂p₁ + |c₁c₂|p₁p₂)/｜c₁c₂ + c₁|c₂|p₂｜ = (p₁ + p₁p₂)/(1 + p₂) = p₁

  Остальные случаи разбираются аналогично.

  Теперь мы можем согласиться с Евой Лу Атор, потому что в случае операций с неточными величинами,
  погрешность в процентах в лучшем случае не увеличивается. Поэтому лучшее, что можно сделать, если
  мы хотим результат с наименьшей погрешностью в процентах, это использовать такие величины только
  тогда, когда это необходимо и если мы можем обойтись без их дублирования, то лучше это и сделать.
|#

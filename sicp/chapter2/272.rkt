#lang sicp

#|
  Упражнение 2.72

  Рассмотрим процедуру кодирования, которую Вы разработали в упражнении 2.68. Каков порядок роста в
  терминах количества шагов, необходимых для кодирования символа? Не забудьте включить число шагов,
  требуемых для поиска символа в каждой следующей вершине. Ответить на этот вопрос в общем случае сложно.
  Рассмотрите особый случай, когда относительные частоты символов таковы, как описано в упражнении 2.71,
  и найдите порядок роста (как функцию от n) числа шагов, необходимых, чтобы закодировать самый частый
  и самый редкий символ алфавита.
|#

#|
  Наш encode-symbol:

    (define (encode-symbol symbol tree)
      (define (encode-1 current-branch)
        (cond ((leaf? current-branch)
              '())
              ((include-symbol? symbol (left-branch current-branch))
               (cons 0 (encode-1 (left-branch current-branch))))
              (else
               (cons 1 (encode-1 (right-branch current-branch))))))

      (if (not (include-symbol? symbol tree))
          (error "symbol not included -- ENCODE-SYMBOL")
          (encode-1 tree)))

    (define (encode message tree)
      (if (null? message)
         '()
          (append (encode-symbol (car message) tree)
                  (encode (cdr message) tree))))

  Рассмотрим особый случай, когда вес распределяется следующим образом:

    ((s₁ 1) (s₂ 2) ... (sₙ 2ⁿ⁻¹))

  Для каждого символа sᵢ мы единожды проверяем наличие в множестве всех символов кодируемых деревом и
  это занимает (n - i + 1) шагов, т.к. символы расположены (и пронумерованы) от самого частого к самому
  редкому. Для самого частого поиск занимает 1 шаг, для самого редкого n шагов. После чего мы проверяем
  наличие символа только в листьях. Для sᵢ мы просматриваем (n - i + 1) листьев. Таким образом, на поиск
  затрачивается 2(n - i + 1) шагов для всех sᵢ, кроме последнего s₁ (т.к. после последней проверки мы
  попадаем не на развилку, а на лист и возвращаем пустое множество).

  Помимо поиска, мы соединяем полученные биты в список, что занимает (n - i + 1) + 1 шагов, т.к. sᵢ-ый
  символ кодируется (n - i + 1) последовательностью бит (кроме s₁, где затрачивается то же количество
  бит, что и у s₂) и так как на последнем шаге мы присоединяем к хвосту пустой список '().

  Итак, для самого частого символа алфавита требуется 4 шага (с поправкой на то, что мы опустили вызовы
  процедур и пр.) и оценка роста числа шагов необходимых для его декодирования O(1).

  Для декодирования самого редкого символа sₙ требуется (3n - 2) шага и рост числа шагов O(n).

  Если брать общий случай дерева Хаффмана, то разумно рассмотреть крайние формы, когда рост числа
  шагов для самого частого и самого редкого символа худший или лучший. В рассмотренном частном случае,
  рост числа шагов для самого редкого и самого частого символа лучший.

  Рассмотрим дерево, где все листья равновесны и каждый символ кодируется одинаковым количеством
  бит (т.е., когда количество символов кратно двум). Такое дерево будет иметь глубину log₂n и каждый
  символ будет кодироваться последовательностью из log₂n бит (для n ≥ 2).

    ((s₁ 1) (s₂ 1) ... (sₙ 1))

  Пример такого дерева:

          (s₄ s₃ s₂ s₁) 4
           /         \
          /           \
      (s₄ s₃) 2     (s₂ s₁) 2
        / \           / \
       /   \         /   \
    s₄ 1   s₃ 1   s₂ 1   s₁ 1

  s₄ → (0 0), s₃ → (0 1), s₂ → (1 0), s₁ → (1 1)

  Тогда для самого "частого" символа потребуется 1 шаг на его поиск перед декодированием и ещё log₂n
  раз для поиска символа в левых ветвях, и log₂n + 1 шагов на cons (log₂n) битa и пустого списка.
  Получаем логарифмический рост O(log(n)).

  Для самого "редкого" символа потребуется n шагов на его поиск перед декодированием и ещё n/2 + ...
  + 1 шагов для поиска на развилках и log₂n + 1 шагов на cons (log₂n) битa и пустого списка. Т.к. n
  кратно двум, то n + n/2 + ... + 1 = 2^{log₂2n} - 1 = 2n - 1. Получаем рост O(n + log(n)) ⊂ O(n).

  Можем ли мы ухудшить ситуацию?

  Представим такое дерево:

              (sₙ ... s₂ s₁) ∑q + q₂ + q₁
                /          \
               /            \
      (sₙ ... s₂) ∑q + q₂   s₁ q₁
             / \
            /   \
          ...   s₂ q₂
          /
         /
      (sₙ sₙ₋₁) qₙ + qₙ₋₁
       / \
      /   \
    sₙ qₙ  sₙ₋₁ qₙ₋₁

  Глубина такого дерева n - 1, поиск самого частого элемента займёт n + 1 шагов. И мы получим оценку роста
  шагов O(n).

  Возникает вполне закономерный вопрос, а могут ли у нашего дерева Хаффмана быть такие qᵢ, что оно
  принимает такой вид? Ведь дерево строится путём объединения наименьших по весу вершин.

  Противоречит это и здравому смыслу, ведь получается, что наиболее длинная последовательность бит
  соответствует самому частому символу.

  Таким образом, худшая оценка для самого частого символа O(log(n)), да и то, это случай, когда самый
  "частый" символ выбирается как самый левый в списке символов корневого узла.
|#

#lang sicp

#|
  Упражнение 1.10

  Следующая процедура вычисляет математическую функцию, называемую функцией Аккермана.

    (define (A x y)
      (cond ((= y 0) 0)
            ((= x 0) (* 2 y))
            ((= y 1) 2)
            (else (A (- x 1)
                     (A x (- y 1))))))

  Каковы значения следующих выражений?

    (A 1 10)

    (A 2 4)

    (A 3 3)

  Рассмотрим следующие процедуры, где A — процедура, определенная выше:

    (define (f n) (A 0 n))

    (define (g n) (A 1 n))

    (define (h n) (A 2 n))

    (define (k n) (* 5 n n))

  Дайте краткие математические определения функций, вычисляемых процедурами f, g и h для
  положительных целых значений n. Например, (k n) вычисляет 5n².
|#

(#%require rackunit)

(define (Akkerman x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (Akkerman (- x 1)
                        (Akkerman x (- y 1))))))

(check-equal? (Akkerman 1 10) 1024)
(check-equal? (Akkerman 2 4) 65536)
(check-equal? (Akkerman 3 3) 65536)

(define (f n) (Akkerman 0 n))

#|
  Процедура f удваивает число n:
    f(n) = 2n
|#

(check-equal? (f 10) 20)
(check-equal? (f 0) 0)
(check-equal? (f -10) -20)

(define (g n) (Akkerman 1 n))

#|
  Процедура g возводит 2 в n-ую степень:
    g(n) = 2ⁿ, где n > 0,
    g(0) = 0

  Если n < 0, то процедура g зацикливается и не возвращает результат.
|#

#|
    (g 1) =>
    (A 1 1) =>
    2

    (g 2) =>
    (A 1 2) =>
    (A 0 (A 1 1)) =>
    (A 0 2) =>
    4

    (g 4) =>
    (A 1 4) =>
    (A 0 (A 1 3)) =>
    (A 0 (A 0 (A 1 2))) =>
    (A 0 (A 0 (A 0 (A 1 1)))) =>
    (A 0 (A 0 (A 0 2))) =>
    (A 0 (A 0 4)) =>
    (A 0 8) =>
    16
|#

(define (^ base degree)
  (cond ((= base 1) 1)
        ((< degree 1) 1)
        (else (* base
                 (^ base (dec degree))))))

(check-equal? (g 0) 0)
(check-equal? (g 1) 2)
(check-equal? (g 5) (^ 2 5))
(check-equal? (g 10) (^ 2 10))
(check-equal? (g 100) (^ 2 100))

(define (h n) (Akkerman 2 n))

#|
  Процедура h(n) возводит результат h(n - 1) во вторую степень:
    h(n) = 2^{2^{2^{...^{2^{2}}}}},
              '-----------------'
                   n - 1 раз
    h(1) = 2,
    h(0) = 0

  Если n < 0, то процедура зацикливается и не возвращает значение.

    (h 3) =>
    (A 2 3) =>
    (A 1 (A 2 2)) =>
    (A 1 (A 1 (A 2 1)) =>
    (A 1 (A 1 2)) => ...
  Мы уже знаем, как ведёт себя (A 1 n), поэтому сразу подставим результат:
    ... => (A 1 2^{2}) =>
    2^{2^{2}}

    (h 5) =>
    (A 2 5) =>
    (A 1 (A 2 4)) =>
    (A 1 (A 1 (A 2 3))) =>
    (A 1 (A 1 (A 1 (A 2 2)))) =>
    (A 1 (A 1 (A 1 (A 1 (A 2 1))))) =>
    (A 1 (A 1 (A 1 (A 1 2)))) =>
    (A 1 (A 1 (A 1 2^{2}))) =>
    (A 1 (A 1 2^{2^{2}})) =>
    (A 1 2^{2^{2^{2}}}) =>
    2^{2^{2^{2^{2}}}}
|#

(check-equal? (h 0) 0)
(check-equal? (h 1) 2)
(check-equal? (h 2) (^ 2 2))
(check-equal? (h 3) (^ 2 (^ 2 2)))
(check-equal? (h 4) (^ 2 (^ 2 (^ 2 2))))
(check-equal? (h 5) (^ 2 (^ 2 (^ 2 (^ 2 2)))))

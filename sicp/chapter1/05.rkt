#lang sicp

#|
  Упражнение 1.5

  Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он
  работает, аппликативным или нормальным. Бен определяет такие две процедуры:

    (define (p) (p))

    (define (test x y)
      (if (= x 0)
          0
          y))

  Затем он вычисляет выражение

    (test 0 (p))

  Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений?
  Какое поведение он увидит, если интерпретатор использует нормальный порядок? Объясните Ваш ответ.
  (Предполагается, что правило вычисления особой формы if одинаково независимо от того,
  какой порядок вычислений используется. Сначала вычисляется выражение-предикат, и результат
  определяет, нужно ли вычислять выражение-следствие или альтернативу.)
|#

#|
  В случае, если интерпретатор использует аппликативный порядок вычислений, процедура test зациклится.
  Интерпретатор не может разрешить подстановку (p) на (p).

    (test 0 (p)) => (test 0 (p)) => (test 0 (p)) => ...
  
  Это происходит и в Scheme, что указывает на аппликативный характер порядка вычислений в этом
  диалекте Lisp.

  Аппликативный порядок вычислений для test((+ 1 (- 4 2)), (+ 1 5)) можно проиллюстрировать так:

    (test x y) => (test (+ 1 (- 4 2)) y) => (test (+ 1 2) y) => (test 3 y) =>
    => (test 3 (+ 1 5)) => (test 3 6) => (if (= 3 0) 0 6) => (if #f 0 6) => 6

  В случае, если интерпретатор использует нормальный порядок вычислений, процедура test не будет
  вычислять x и y до тех пор, пока они не понадобятся.
  При аргументах (0, (p)) мы не попадаем в ветку else оператора if, а значит (p) не будет вычисляться
  и процедура не зациклится.
  Процедура при нормальном порядке вычислений сработала бы и с такими аргументами:
  
    (test 0 (/ 1 0)) => 0

  Нормальный порядок вычислений test((+ 1 (- 4 2)), (+ 1 5)) можно проиллюстрировать так:

    (test x y) => (if (= x 0) 0 y) => (if (= (+ 1 (- 4 2)) 0) 0 y) => (if (= (+ 1 2) 0) 0 y) =>
    => (if (= 3 0) 0 y) => (if #f 0 y) => y => (+ 1 5) => 6
|#

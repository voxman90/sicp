#lang sicp

#|
  В случае аппликативного порядка вычисления процедура test зациклится, потому что интерпретатор
  никогда не сможет разрешить подстановку (p) на (p). Это происходит и в Scheme, что указывает на
  аппликативных характер порядка вычислений (по-крайней мере, по умолчанию).

  В случае нормального порядка вычисления, процедура test не будет вычислять y, потому
  что при таких аргументах (0 (p)) мы никогда не попадаем в альтернативную ветку особой формы if.
  Можно было бы написать (test 0 (/ 1 0)) и даже тогда программа вернула бы 0 и не завершилась с
  ошибкой.
|#

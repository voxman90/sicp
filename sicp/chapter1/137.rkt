#lang sicp

#|
  Упражнение 1.37

  а. Бесконечная цепная дробь (continued fraction) есть выражение вида:

               N₁
    f = ---------------
                    N₂
         D₁ + -------------
                        N₃
               D₂ + ----------
                     D₃ + ...

  В качестве примера можно показать, что расширение бесконечной цепной дроби при всех Nᵢ и Dᵢ,
  равных 1, дает 1/φ, где φ — золотое сечение (описанное в разделе 1.2.2). Один из способов
  вычислить цепную дробь состоит в том, чтобы после заданного количества термов оборвать вычисление.
  Такой обрыв — так называемая конечная цепная дробь (finite continued fraction) из k элементов, —
  имеет вид:

             N₁
     ------------------
                  N₂
      D₁ + ---------------
                       Nₖ
            D₂ + ... -----
                       Dₖ

  Предположим, что n и d — процедуры одного аргумента (номера элемента i), возвращающие Nᵢ и Dᵢ
  элементов цепной дроби. Определите процедуру cont-frac так, чтобы вычисление (cont-frac n d k)
  давало значение k-элементной конечной цепной дроби. Проверьте свою процедуру, вычисляя
  приближения к 1/φ с помощью

    (cont-frac (lambda (i) 1.0)
               (lambda (i) 1.0)
               k)

  для последовательных значений k. Насколько большим пришлось сделать k, чтобы получить приближение,
  верное с точностью 4 цифры после запятой?

  б. Если Ваша процедура cont-frac порождает рекурсивный процесс, напишите вариант, который
  порождает итеративный процесс. Если она порождает итеративный процесс, напишите вариант,
  порождающий рекурсивный процесс.
|#

(#%require rackunit)

(define (inc n) (+ n 1))

(define (dec n) (- n 1))

(define (cont-frac-rec term-n term-d k)
  (define (cont-frac i)
    (if (> i k)
        0
        (/ (term-n i)
           (+ (term-d i) (cont-frac (inc i))))))

  (cont-frac 1))

(define (cont-frac-iter term-n term-d k)
  (define (cont-frac acc i)
    (if (< i 1)
        acc
        (cont-frac (/ (term-n i)
                      (+ (term-d i) acc))
                   (dec i))))

  (cont-frac 0 k))

(define (test k)
  (cont-frac-rec (lambda (_) 1.0)
                 (lambda (_) 1.0)
                 k))

(define (golden-ratio k)
  (+ 1 (cont-frac-iter (lambda (_) 1.0)
                       (lambda (_) 1.0)
                       k)))


(check-equal? (round (* 1000 (test 100))) 618.0)
(check-equal? (round (* 1000 (golden-ratio 100))) 1618.0)

#|
  Потребовалось взять k равное 12, чтобы с округлением получить точность в четыре знака
  после запятой. Если "отсечь" хвост без округления, достаточно и 11.
|#

(check-equal? (round (* 10000 (golden-ratio 12))) 16180.0)

#lang sicp

#|
  Упражнение 1.14

  Нарисуйте дерево, иллюстрирующее процесс, который порождается процедурой count-change из
  раздела 1.2.2 при размене 11 центов. Каковы порядки роста памяти и числа шагов, используемых
  этим процессом при увеличении суммы, которую требуется разменять?
|#

(#%require rackunit)

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount (- kinds-of-coins 1))
                 (cc (- amount (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

#|
    (сс 11 5)
    ├── (сс 11 4)
    │   ├── (сс 11 3)
    │   │   ├── (сс 11 2)
    │   │   │   ├── (сс 11 1)
    │   │   │   │   ├── (сс 11 0) => 0
    │   │   │   │   └── (сс 10 1)
    │   │   │   │       ├── (сс 10 0) => 0
    │   │   │   │       └── (cc 9 1)
    │   │   │   │           ├── (сс 9 0) => 0
    │   │   │   │           └── (cc 8 1)
    │   │   │   │               ├── (сс 8 0) => 0
    │   │   │   │               └── (cc 7 1)
    │   │   │   │                   ├── (сс 7 0) => 0
    │   │   │   │                   └── (cc 6 1)
    │   │   │   │                       ├── (сс 6 0) => 0
    │   │   │   │                       └── (cc 5 1)
    │   │   │   │                           ├── (сс 5 0) => 0
    │   │   │   │                           └── (cc 4 1)
    │   │   │   │                               ├── (сс 4 0) => 0
    │   │   │   │                               └── (cc 3 1)
    │   │   │   │                                   ├── (сс 3 0) => 0
    │   │   │   │                                   └── (cc 2 1)
    │   │   │   │                                       ├── (сс 2 0) => 0
    │   │   │   │                                       └── (cc 1 1)
    │   │   │   │                                           ├── (сс 1 0) => 0
    │   │   │   │                                           └── (cc 0 1) => 1
    │   │   │   └── (cc 6 2)
    │   │   │       ├── (cc 6 1)
    │   │   │       │   ├── (сс 6 0) => 0
    │   │   │       │   └── (cc 5 1)
    │   │   │       │       ├── (сс 5 0) => 0
    │   │   │       │       └── (cc 4 1)
    │   │   │       │           ├── (сс 4 0) => 0
    │   │   │       │           └── (cc 3 1)
    │   │   │       │               ├── (сс 3 0) => 0
    │   │   │       │               └── (cc 2 1)
    │   │   │       │                   ├── (сс 2 0) => 0
    │   │   │       │                   └── (cc 1 1)
    │   │   │       │                       ├── (сс 1 0) => 0
    │   │   │       │                       └── (cc 0 1) => 1
    │   │   │       └── (сс 1 2)
    │   │   │           ├── (сс 1 1)
    │   │   │           │   ├── (сс 1 0) => 0
    │   │   │           │   └── (сс 0 1) => 1
    │   │   │           └── (сс -4 2) => 0
    │   │   └── (сс 1 3)
    │   │       ├── (сс 1 2)
    │   │       │   ├── (сс 1 1)
    │   │       │   │   ├── (сс 1 0) => 0
    │   │       │   │   └── (сс 0 1) => 1
    │   │       │   └── (сс -4 2) => 0
    │   │       └── (сс -9 3) => 0
    │   └── (cc -14 4) => 0
    └── (cc -39 5) => 0

  Для построения дерева использовался сайт: https://tree.nathanfriend.io/

  Пусть у нас имеется всего один тип монет (1 цент):

    (cc n 1)
    ├── (cc n 0) => 0
    └── (cc n-1 1)
        ├── (cc n-1 0) => 0
        └── (cc n-2 1)
            └── ...
                ├── (cc 2 0) => 0
                └── (cc 1 1)
                    ├── (cc 1 0) => 0
                    └── (cc 0 1) => 1

  Подсчитаем количество шагов: первоначальный вызов процедуры и n раздвоений дерева вызовов.
  Обозначим количество шагов процедуры сс для числа n и количества типов монет k как S(n, k).
  Условимся, что n ∊ ℕ ⋃ {0}, k ∊ ℕ.
  Тогда:

    S(n, 1) = 2n + 1

    2n ≤ S(n, 1) ≤ 2n + n = 3n

  Для S(n, 1) порядок роста числа шагов θ(n), что можно записать, как S(n, 1) ⊂ θ(n).

  Добавим ещё один тип монет (5 центов):

    (cc n 2)
    ├── (cc n 1) <=> S(n, 1)
    └── (cc n-5 2)
        ├── (cc n-5 1) <=> S(n - 5, 1)
        └── (cc n-10 2)
            ├── (cc n-10 1) <=> S(n - 10, 1)
            └── (cc n-15 2)
                ├── ...
                └── ...
                    ├── (cc n-5(⌈n/5⌉-1) 1) <=> S(n-5(⌈n/5⌉-1), 1)
                    └── (cc n-5⌈n/5⌉ 2) => 0 | => 1

  Подсчитаем количество шагов: первоначальный вызов процедуры и дерево вызовов раздваивается
  ⌈n/5⌉ раз, где одна из ветвей включает в себя S(n - 5m, 1) шагов, где m пробегает целые значения от
  0 до ⌈n/5⌉ - 1.
  Тогда:

    S(n, 2) = ∑ₘS(n - 5m, 1) + ⌈n/5⌉ + 1, m ∊ [0, ⌈n/5⌉ - 1]

    S(n, 2) = (2n + 1) + (2(n - 5) + 1) + ... + (2(n - 5(⌈n/5⌉ - 1)) + 1) + ⌈n/5⌉ + 1 =

    = 2n + 1 + 2n - 10 + 1 + ... + 2n - 10⌈n/5⌉ + 10 + ⌈n/5⌉ + 1 =

    = (2n + ... + 2n) + (1 + ... + 1) + ⌈n/5⌉ + 1 - 10(1 + ... + (⌈n/5⌉ - 1)) =

    = 2n⌈n/5⌉ + 2⌈n/5⌉ + 1 - 10(1 + ... + (⌈n/5⌉ - 1)) =

  Вспомним, что 1 + 2 + ... + m = m(m + 1)/2:

    = ⌈n/5⌉(2n + 2) + 1 - 10((⌈n/5⌉ - 1)⌈n/5⌉/2) = ⌈n/5⌉(2n + 2) - ⌈n/5⌉(5⌈n/5⌉ - 5) + 1 =

    = ⌈n/5⌉(2n - 5⌈n/5⌉ + 7) + 1

  Проверим эту формулу для ряда частных случаев:
|#

(define (S2 n)
  (define ceil (ceiling (/ n 5)))
  (+ 1
     (* ceil
        (+ (* 2 n)
           (- (* 5 ceil))
           7))))

(define (cc-step-counter amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 1)
        (else (+ 1
                 (cc-step-counter amount (- kinds-of-coins 1))
                 (cc-step-counter (- amount (first-denomination kinds-of-coins))
                                  kinds-of-coins)))))

(check-equal? (cc-step-counter 0 2) 1)
(check-equal? (cc-step-counter 10 2) 35)
(check-equal? (cc-step-counter 0 2) (S2 0))
(check-equal? (cc-step-counter 10 2) (S2 10))
(check-equal? (cc-step-counter 30 2) (S2 30))
(check-equal? (cc-step-counter 31 2) (S2 31))

#|
  Пусть dᵢ номинал (denomination) i-ого типа монет. Номинал монет упорядочен по убыванию.
  Легко заметить, что:

    S(n, i) = ∑ₘS(n - dᵢm, i - 1) + ⌈n/dᵢ⌉ + 1, m ∊ [0, ⌈n/dᵢ⌉ - 1] (1)

  Интуитивно ясно, что порядок роста числа шагов будет O(nⁱ). Доказательство,
  предполагающее фактический подсчёт шагов через формулу (1) требует весьма трудоёмких
  вычислений, поэтому попытаемся оценить функцию сверху и снизу, выполнив ряд преобразований.
  Для n ≥ 5:

    S(n, 2) = ⌈n/5⌉(2n - 5⌈n/5⌉ + 7) + 1 < ⌈n/5⌉(2n + 7) + 1 <* n/2(2n + 7) + 1 =

    = n² + 3.5n + 7 <** 2n²

    * n/5 ≤ ⌈n/5⌉ ≤ n/5 + 1; n/2 > n/5 + 1, n ∊ (10/3, ∞).

    ** n² > 3.5n + 7, n ∊ (-∞, (7 - √161)/4) ∪ ((7 + √161)/4, ∞),

    (7 + √161)/4 < (7 + √169)/4 = 20/4 = 5, следовательно, n² + 3.5n + 7 < 2n² для n ≥ 5.

  В дальнейшем я буду опускать обоснование тривиальных преобразований, потому что это не относится
  к сути упражнения.

    S(n, 2) = ⌈n/5⌉(2n - 5⌈n/5⌉ + 7) + 1 > ⌈n/5⌉(2n - 5⌈n/5⌉) > n/5(2n - 5(n/5 + 1)) = n/5(n - 5) =

    = n²/5 - n > n²/10

    n²/10 < S(n, 2) < 2n²

  Таким образом, S(n, 2) ⊂ θ(n²).

  Теперь мы можем оценить S(n, 3), подставив вместо S(n, 2) её верхнюю и нижнюю оценку. Будем
  рассматривать n ≥ 10.

    S(n, 3) < ∑ₘ2(n - 10m)² + ⌈n/10⌉ + 1 ≤ ∑ₘ₌₀2n² + n + 1 = 2n²⌈n/10⌉ + n + 1 <

    < 2n³ + n + 1 < 3n³

    S(n, 3) > ∑ₘ(n - 10m)²/10 + ⌈n/10⌉ + 1 > ∑ₘ₌₀(n - 10m)²/10 = ∑ₘ₌₀(n² - 20nm + 100m²)/10 =

    = ⌈n/10⌉n²/10 - n(⌈n/10⌉ - 1)⌈n/10⌉ + 5⌈n/10⌉(⌈n/10⌉ - 1)(2⌈n/10⌉ - 1)/3 >

    > 5⌈n/10⌉(⌈n/10⌉ - 1)(2⌈n/10⌉ - 1)/3 > 5(n/10 + 1)(n/10 - 1)(n/5 - 1)/3 =

    = (n + 10)(n - 10)(n - 5)/300 > n³/1000, n > 13.7537

  Таким образом, мы показали, что S(n, 3) ⊂ θ(n³). Проверим наши выводы на практике:
|#

(check-equal? (cc-step-counter 1 3) 7)
(check-equal? (cc-step-counter 4 3) 13)
(check-equal? (cc-step-counter 5 3) 15)

(define (cube n)
  (* n n n))

(define (S3-lesser n)
  (/ 1000 (cube n)))

(define (S3-greater n)
  (* 3 (cube n)))

(check-equal? (< (cc-step-counter 11 3) (S3-greater 11)) #t)
(check-equal? (> (cc-step-counter 11 3) (S3-lesser 11)) #t)
(check-equal? (< (cc-step-counter 1000 3) (S3-greater 1000)) #t)
(check-equal? (> (cc-step-counter 1000 3) (S3-lesser 1000)) #t)

#|
  Для 1 ≤ i ≤ 3 показано, что количество шагов имеет порядок θ(nⁱ).

  Проверим для S(n, 4).

    S(n, 4) = ∑ₘS(n - 25m, 3) + ⌈n/25⌉ + 1, m ∊ [0, ⌈n/25⌉ - 1].

  Для оценки сверху, можно заменить S(n - 25m, 3) её верхней оценкой и вместо суммы по всем m
  взять ⌈n/25⌉ раз наибольшее слагаемое.
  Учитывая возрастающий характер функции, это даст верхнюю оценку для S(n, 4). Так как у нас нет
  не рекурсивной формулы для S(n, 3) мы так же будем брать её верхнюю оценку, которую
  получили до этого.

    S(n, 4) < ∑ₘ3(n - 50m)³ + ⌈n/25⌉ + 1 < ⌈n/25⌉3n³ + ⌈n/25⌉ + 1 = ⌈n/25⌉(3n³ + 1) + 1 <

    < (n/25 + 1)(3n³ + 1) + 1 = 3n⁴/25 + 3n³ + n/25 + 2 < n⁴

  Теперь мы можем оценить S(n, 5) сверху:

    S(n, 5) = ∑ₘS(n - 50m, 4) + ⌈n/50⌉ + 1, m ∊ [0, ⌈n/50⌉ - 1],

    S(n, 5) < ∑ₘ(n - 50m)⁴ + ⌈n/50⌉ + 1 < ⌈n/50⌉n⁴ + ⌈n/50⌉ + 1 < ⌈n/50⌉(n⁴ + 1) + 1 <

    < (n/50 + 1)(n⁴ + 1) + 1 = n⁵/50 + n⁴ + n/50 + 2 < n⁵

  Таким образом, S(n, 4) ⊂ O(n⁴) и S(n, 5) ⊂ O(n⁵).
|#

#lang racket

#|
  Упражнение 3.8

  Когда в разделе 1.1.3 мы определяли модель вычислений, мы сказали, что первым шагом при вычислении
  выражения является вычисление его подвыражений. Однако мы нигде не указали порядок, в котором проходит
  вычисление подвыражений (слева направо или справа налево). Когда мы вводим присваивание, порядок, в
  котором вычисляются аргументы процедуры, может повлиять на результат. Определите простую процедуру f,
  так, чтобы вычисление (+ (f 0) (f 1)) возвращало 0, если аргументы + вычисляются слева направо, и 1,
  если они вычисляются справа налево.
|#

(#%require rackunit)

(define (make-f)
  (let ((acc 'none))
    (lambda (x)
      (if (eq? acc 'none)
          (begin
            (set! acc x)
            0)
          acc))))

(define f (make-f))
(define g (make-f))

(check-equal? (+ (f 0) (f 1)) 0)
(check-equal? (+ (g 1) (g 0)) 1)

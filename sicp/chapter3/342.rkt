#lang sicp

#|
  Упражнение 3.42

  Бен Битобор говорит, что слишком расточительно в ответ на каждое сообщение withdraw и deposit создавать
  по новой сериализованной процедуре. Он говорит, что можно изменить make-account так, чтобы все вызовы
  protected происходили вне процедуры dispatch. Таким образом, счет будет возвращать одну и ту же
  сериализованную процедуру (созданную тогда же, когда и сам счет) каждый раз, когда у него просят
  процедуру снятия денег:

    (define (make-account balance)
      (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
      (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
      (let ((protected (make-serializer)))
        (let ((protected-withdraw (protected withdraw))
              (protected-deposit (protected deposit)))
          (define (dispatch m)
            (cond ((eq? m 'withdraw) protected-withdraw)
                  ((eq? m 'deposit) protected-deposit)
                  ((eq? m 'balance) balance)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))
          dispatch)))

  Безопасно ли такое изменение? В частности, есть ли разница в том, в каком порядке может происходить
  параллельное выполнение в этих двух версиях make-account?
|#

#|
  По определению из книги, сериализатор работает следующим образом: "процессы выполняются параллельно,
  но при этом существуют определенные группы процедур, которые не могут выполняться одновременно.
  Выражаясь точнее, сериализация порождает выделенные множества процедур, такие, что в каждом сериализованном
  множестве в любой момент может происходить выполнение только одной процедуры из множества. Если какая-то
  процедура из множества уже выполняется, то процесс, который пытается выполнить любую процедуру из
  множества, будет приостановлен до тех пор, пока не закончится текущее вычисление процедуры."

  Так как при выполнении какой-либо процедуры из выделенного множества, процесс, который попытается
  выполнить любую процедуру из выделенного множества будет приостановлен, то и параллельные вызовы одной
  и той же процедуры из выделенного множества будут выполняться безопасно (и последовательно).

  В первом случае, в нашей программе множество сериализованных процедур пополнялось при каждом обращении
  через диспетчеризатор. В модифицированной версии, это множество не пополняется и состоит из двух процедур,
  которые не будут вмешиваться как в работу друг друга, так и в работу своих параллельных вызовов.

  Разницы в возможном порядке выполнения процедур между модифицированной и оригинальной версией нет, с
  поправкой на обращения к сериализатору и т.д.
|#

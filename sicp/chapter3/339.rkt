#lang sicp

#|
  Упражнение 3.39

  Какие из пяти возможных исходов параллельного выполнения сохраняются, если мы сериализуем выполнение
  таким образом:

    (define x 10)

    (define s (make-serializer))

    (parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                      (s (lambda () (set! x (+ x 1)))))
|#

#|
  Сперва вспомним о каких пяти возможных исходах идёт речь и как они возникают. Пусть процедура
  f - это (lambda () (set! x (* x x))), а вторая процедура g - это (lambda () (set! x (+ x 1))).

  1) отрабатывает процедура f и присваивает x значение 100, отрабатывает процедура g и присваивает x
  значение 101.

  2) отрабатывает процедура f и присваивает x значение 11, отрабатывает процедура g и присваивает x
  значение 121.

  3) отрабатывает процедура f, отрабатывает процедура g и присваивает x значение 11, после чего
  процедура f присваивает x значение 100.

  4) отрабатывает процедура g, отрабатывает процедура f и присваивает x значение 100, после
  чего процедура g присваивает x значение 11.

  5) между обращениями процедуры f к x отрабатывает процедура g и записывает в x значение 11, потом
  процедура f записывает в x значение 110

  После добавления сериализации f имеет вид (lambda () (set! x ((s (lambda () (* x x)))))), а процедура
  g имеет вид (s (lambda () (set! x (+ x 1)))).

  Естественно, что сохраняются исходы 1 и 2, т.к. сериализация не препятствует последовательному
  выполнению процедур.

  Исход 5 становится невозможен, так как процедура g не может вмешаться в ход процедуры (s (lambda ()
  (* x x)).

  Т.к. присваивание в процедуре f не сериализованно, то оно может прозойти как после, так и до завершения
  выполнения процедуры g, потому сохраняется исход 3 и 4. Итого, такая частичная сериализация способна
  привести к четырём различным исходам: 1, 2, 3, 4.
|#

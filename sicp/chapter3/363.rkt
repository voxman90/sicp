#lang racket

#|
  Упражнение 3.63

  Хьюго Дум спрашивает, почему нельзя было написать sqrt-stream более простым способом, без внутренней
  переменной guesses:

    (define (sqrt-stream x)
      (cons-stream 1.0
                   (stream-map (lambda (guess)
                                 (sqrt-improve guess x))
                               (sqrt-stream x))))

  Лиза П. Хакер отвечает, что эта версия процедуры значительно менее эффективна, поскольку производит
  избыточные вычисления. Объясните Лизин ответ. Сохранилось бы отличие в эффективности, если бы реализация
  delay использовала только (lambda () <exp>), без оптимизации через memo-proc (см. раздел 3.5.1)?
|#

#|
  Первоначальная версия процедуры:

    (define (sqrt-stream x)
      (define guesses
        (cons-stream 1.0
                     (stream-map (lambda (guess)
                                   (sqrt-improve guess x))
                                 guesses)))
      guesses)

  Первоначальная версия обладает тем преимуществом, что guesses представляет из себя поток, а в реализацию
  потоков вшита мемоизация. Почему это важно? Потому что мы в процессе вычисления приближения постоянно
  обращаемся к предыдущему значению приближения. Без мемоизации, нам бы пришлось пробегать guesses с самого
  начала и, если дать быструю оценку, то затрачивать 1 + 2 + ... + n - 1 = (n - 1)(n - 2)/2 дополнительных
  шагов для рассчёта n-ого значения приближения.

  Версия Хьюго плоха тем, что не использует мемоизацию: каждый раз при вызове (sqrt-stream x) создаётся
  новый поток, соответственно, для его версии вообще не важно, используют ли потоки мемоизацию или нет.

  Если реализовать потоки без мемоизации, первоначальная версия будет затрачивать аналогичное число шагов.

  Таким образом, её преимущество не сохранится без мемоизации.
|#
